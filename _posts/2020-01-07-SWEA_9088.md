---
layout: post
title: "SW Expert Academy 9088번 다이아몬드 문제 풀이"
subtitle: ""
categories : dev
tags : algorithm
date: 2020-1-7 21:00:00 +0900
background: '/img/posts/06.jpg'
---

 [SW Expert Acadmy 9088. 다이아몬드 문제 (D4)](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AW7Oktj6WMQDFAWY&categoryId=AW7Oktj6WMQDFAWY&categoryType=CODE&&&)  

복사가 금지되어있으니 문제는 위 링크 참고.

# 문제 요약
 크기가 같거나 다른 N개의 다이아몬드가 있을 때, 크기 차이가 K이하인 다이아몬드를 선택한다. 이때 선택할 수 있는 최대 다이아몬드의 개수를 구해야한다.


# 문제 풀이 
## 풀이 1
  Brute force(완전탐색) 방법으로 '모두 다 선택했을때, 전체에서 1개를 뺐을 때, 전체에서 2개를 뺐을 때 ~ 전체에서 N-1개를 뺼 때'까지 빼는 개수를 늘려가면서, 빼지않고 남은 다이아몬드 간의 크기차이가 최초로 K이하가 되는 다이아몬드의 개수'를 찾아 볼 수 있다. 이 방법으로 문제가 풀리긴하겠지만, 
  코드를 짜기도 어렵고, 대략`N-1 * 각 경우의 뺴는 다이아몬드 조합의 수 * 각 경우의 뺴지 않은 다이아몬드 수(최대,최소 찾기)` 만큼의 많은 계산이 필요하다..  
  이 방법의 문제점은 크기차이가 K이하라는 조건을 제대로 활용하지 못했다는 것이다. 크기 차이가 K이하라는 것은 어떤 크기를 기준으로 최대 K만큼 큰 다이아몬드까지만 확인하면 된다는 뜻이다.
  문제의 조건은 문제의 범위를 제한해주는 것이며, 풀이에서 집중해야할 부분이다. (문제)조건은 알고리즘을 효율적으로 만들 수 있는 힌트가 된다는 것을 알아두어야 한다.

## 풀이 2
   그럼 위의 조건을 이용한 풀이를 생각해보면, 모든 크기에 대해서 '그 크기+ K'의 크기를 갖는 다이아몬드의 개수를 세는 것이다.예를들어 다이아몬드가 1~100까지의 크기를 갖고, K가 3이라면..  
  크기가 1~4인 것의 개수, 크기가 2~5인 것의 개수, 크기가 97~100인 것의 개수 중에서 가장 큰 값을 찾으면 된다.

## 작성한 알고리즘 반례 찾기 

 ``` C++
 // min : 입력받은 다이아몬드 중 최소값
 // max : 입력받은 다이아몬드 중 최대값.
  for (int j = min; j <= max - diff; ++j) // 크기가 j인 다이아몬드 ~ j + diff의 개수 합 탐색.
		{
			for (int k = 0; k < dias.size(); ++k) // 입력받은 벡터 내부 탐색, 조건만족하는 것의 원소 개수
			{
				if (dias[k] > j + diff) break; // 정렬된 상태이므로, 그 이상은 탐색할 필요 없음.
				else if (dias[k] <= j + diff && dias[k] >= j)
					++dia_count;
			}

			if (dia_count > num_max) num_max = dia_count;
			dia_count = 0;
		}
 ```
 처음에 나는 알고리즘을 효율적으로 하기위해서 가장 바깥 for문(각 크기~크기+k의 다이아몬드 탐색하는 반복문)의 조건문을 위와 같이 j <= max - diff로 했었다가 채점시 10개중 10번째에서 오답이라는 결과를 받았다.
  생각해보면 diff가 max값보다 큰 경우 반복문 진입이 되지않아서 그렇다...
``` C++
 for(int j = min; j < max; ++j){

 }
```
로 수정하면 정답이 뜬다.


## Discussion
문제를 잘 이해하고, 조건만 잘 활용하면 코드도 짧고, 쉽게 풀 수 있는 문제였다.  




# 기타
 문제 풀이를 생각하는 과정에서 [1, 1, 2, 3]과 같이 중복된 값을 갖는 배열에서 3개를 뽑는 경우의 수를 구하는 방법이 궁금해졌다. 이 예시에서는 [1, 1, 2], [1, 1, 3], [1, 2, 3] 3가지로 쉽게 구할 수 있는데, 일반적으로는 어떻게 구할 수 있을까.

### 중복조합?
   예를들면 1, 2, 3 세 개를 중복해서 4개를 뽑는 경우가 중복조합이다. 중복조합이라면 [1,1,1,1], [1,1,1,2], ...과 같이 나올 수 있다. 그러나 이 문제에서 1은 최대 2개까지만 뽑을 수 있다. 이 부분이 틀리다.
  

### 중복순열?
중복 순열은 쉬운 예로 [1,2,3]가 있을 때 중복을 허용하고, 순서를 고려하여 뽑는 것이다. 역시나 이 경우와는 다르다.


### Case 분리?
  내가 든 예시에서는 1의 개수에 따라 case를 나누어서 생각해 볼 수 있다. 이 예시에서는 1이 1개일때와 1이 2개일때를 나누어서 생각하는 것이다.  
  - 1이 1개일 때는 나머지 2개를 [2, 3]에서 2개를 뽑아야하므로 1개이고,  
  - 1이 2개일 때는 나머지 1개를 [2, 3]에서 1개를 뽑아야하므로 2개이다.  
  그러므로 총 3개이다.  그러나 이 방법은 [1,1,1,2,2,3,3,3,4,4,5,6,7]에서 3개를 뽑는 경우와 같이 조금만 복잡해져도 case를 일일이 다 나누기 힘들어진다..